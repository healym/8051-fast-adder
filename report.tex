\documentclass[journal]{IEEEtran}
\usepackage{graphics}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}

\begin{document}


\title{Implementation of a Carry Lookahead Fast Adder}
\author{
	Healy, Matthew
	\texttt{mhealy@mst.edu}\\
	\and
	Johnston, Jaxson
	\texttt{jnjt37@mst.edu}\\
	\and
	Grbe\`sa, Lukas
	\texttt{lgqq3@mst.edu}\
}

\maketitle


\begin{abstract}
% write after results calculated

\end{abstract}

\section{Introduction}\label{sec:intro}
The carry lookahead adder was originally patented by Intel\cite{patent} in 1957.
As time passed and technology improved, this method of addition was shown
to be even more useful than originally thought, as it allows for the quick
computation of numbers that would take a non-insignificant amount of time
using the traditional ripple-carry method.

Our goal in this project is to implement a simulation of a carry lookahead
adder on the 8051 microcontroller as a proof of concept. Since execution is
serial, this simulation will not be faster than the built-in adding operations,
as we are unable to calculate multiple things at once, as we could were we
building a hardware model of a carry lookahead adder.

\section{Results and Discussion}\label{sec:discuss}

By first generating our Propogate($P$) and Generate($G$) strings from the input,
and then stepping through our carry input and deriving each bit from the
$P$ and $G$ strings and the previous carry bit, we emulate the stages of
operation of a carry lookahead adder.

The creation of the $P$ and $G$ strings solely from the input strings emulates
the stage in which each bit of each input is XORed and ANDed together, to create
the $P$ and $G$ terms for each bit. This would be done in hardware with blocks
of two logic gates all operating in parallel, and would take approximately
$2\Delta t$ to complete.

The next stage, wherein the $P$ and carry bit are XORed together to create the
sum, is emulated by a loop that XORs bytes of the carry string with bytes of
the $P$ string. While this adds another n time in the software solution, it
would implement only another $2\Delta t$ in a hardware solution, since it would
bo only two more logic gates for each bit, all operating in parallel.

The following pseudocode\ref{alg:pseudo}
shows the basic implementation of this simulation:
\begin{algorithm}[H]
\label{alg:pseudo}
\caption{Pseudocode for CLA Adder}
\begin{algorithmic}
\State R3 $\rightarrow$ carry string
\State R6 $\rightarrow$ Input A
\State R7 $\rightarrow$ Input B

\ForAll{bytes $P_i\in P, G_i\in G, RX_i\in RX$}
	\State $P \gets R6 \oplus R7$
	\State $G \gets R6 \land R7$
\EndFor
\ForAll{bits $C_i\in C, P_i\in P, G_i\in G$}
	\State $C \gets G \lor (P \land C)$
\EndFor

\ForAll{bytes $SUM_i\in SUM, C_i\in C, P_i\in P$}
	\State $SUM_i \gets C_i \oplus P_i$
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{figure}
	\includegraphics{}
	\caption{Input Size vs Computation Time}
	\label{fig:time}
\end{figure}

As can be seen in Fig. \ref{fig:time}, this software simulation falls far
short of the speed of its hardware implementation. However, it does match very
closely the speed of a ripple-carry add on the 8051 microcontroller, changing
only the constant in the time-complexity.

\section{Summary and Conclusion}

\section{Source Code}\label{sec:code}

\lstinputlisting[language=Assembler, firstline=13]
{fast_addr.asm}

\begin{thebibliography}{99}

  % Book
  \bibitem{Weste93} Neil H. E. Weste and Kamran Eshraghian, {\it Principles
  of CMOS VLSI Design}, 2nd ed. Reading, MA: Addison-Wesley, 1993.

  %Example of a Conference Paper
  \bibitem{LiY88} R. A. Lincoln and K. Yao, ``Efficient Systolic Kalman
  Filtering Design by Dependence Graph Mapping,'' in {\it VLSI Signal
  Processing, III}, IEEE Press, R. W. Brodersen and H. S. Moscovitz Eds.,
  1988, pp.~396--410.

  % Example of a Journal Paper
  \bibitem{BiS92} C. H. Bischof and G. M. Shroff, ``On Updating Signal
  Subspaces,'' {\it IEEE Trans. on Signal Processing}, vol.~40, no.~1,
  pp.~96--105, Jan. 1992.

\end{thebibliography}
\end{document}
