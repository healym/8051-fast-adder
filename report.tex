\documentclass[journal]{IEEEtran}
\usepackage{graphics}

\begin{document}


\title{Implementation of a Carry Lookahead Fast Adder}
\author{
	Healy, Matthew
	\texttt{mhealy@mst.edu}\\
	\and
	Johnston, Jaxson
	\texttt{jnjt37@mst.edu}\\
	\and
	Grbe\`sa, Lukas
	\texttt{lgqq3@mst.edu}\
}

\maketitle


\begin{abstract}
% write after results calculated

\end{abstract}

\section{Introduction}\label{sec:intro}
The idea for a carry lookahead adder was originally patented by Intel in 1957.
As time passed and technology improved, this method of addition was shown
to be even more useful than originally thought, as it allows for the quick
computation of numbers that would take a non-insignificant amount of time
using the traditional ripple-carry method.

Our goal in this project is to implement a simulation of a carry lookahead
adder on the 8051 microcontroller as a proof of concept. Since execution is
serial, this simulation will not be faster than the built-in adding operations,
as we are unable to calculate multiple things at once, as we could were we
building a hardware model of a carry lookahead adder.

\section{Results and Discussion}\label{sec:discuss}

Before any assembly code was written, the group considered several different
methods to create an efficient carry lookahead adder. Before any discussion
could be had about how to create a carry look-ahead, we had to understand
how a regular full adder works and a ripple carry adder, in order to
understand how to make a more efficient adder. Once we understood the
functionality and flaws of each adder, we were ready to create a more
efficient adder. Even though we understood the basic approach on how to
make a more efficient adder, it took multiple tries to get our desired code.

\subsection{Pseudocode}\label{sec:pseudo}
\begin{verbatim}
R3 -> carry string
R6 -> Input A
R7 -> Input B

Loop through bytes:
	P = R6 XOR R7
	G = R6 AND R7

Loop through bits:
	C = G OR (P AND C)

Loop through bytes:
	SUM = C XOR P
\end{verbatim}

The first attempt at writing the assembly code took multiple hours to create
because the group was mostly trying to figure out how to create a piece of
code that will create a functional carry look-ahead adder. Even though our
code seemed to work, we noticed that if we tested it that it would not be
faster than a ripple carry adder. The problem with our approach was that we
were adding one bit at a time. Because we chose this method, there was
extraneous use of the carry flag because the carry flag had to be used in
every bit wise operation. Once we realized that our code was not as efficient
as it needed to be, we started troubleshooting ways we could change our code
to be more efficient. The answer we came up with was to store the data in
multiple registers and execute it by using the XOR function on bytes,
rather than bits.

\section{Summary and Conclusion}

\section{Source Code}\label{sec:code}

I like using the \verb"verbatim" specification for computer code.
For example, here is something that appears in several
languages:

\begin{verbatim}
        MOV R3, #40H   ; #10H bit
        MOV R6, #48H   ; #40H bit
        MOV R7, #50H   ; #70H bit
        MOV R5, R2     ; length of operands stored in R2

  LOAD: MOV R4, @R6    ; temp hold for byte of R6 data
        XRL @R6, @R7   ; propagate
        ANL @R7, R4    ; generate
        INC R6         ; move to next bit of P
        INC R7         ; move to next bit of G
        DNJZ R5, LOAD

        MOV R5, R2     ; reset R5
        MUL R5, #8H    ; switch to bit counter
        MOV R5, A      ; load counter with length*8
        CLR C          ; C will be used as Ci in boolean equation
        MOV R6, #040H  ; bit addr
        MOV R7, #070H  ; bit addr

 CARRY: ANL C, @R6     ; intermediate = Ci AND P(i+1)
        ORL C, @R7     ; C(i+1) = intermediate OR G(i+1)
        MOV @R3, C     ; store C(i+1) in carry string
        INC R3         ; move to next bit of carry string
        INC R6         ; move to next bit of P
        INC R7         ; move to next bit of G
        DJNZ R5, CARRY

        MOV R3, #40H   ; reload R3 with start of carry string
        MOV R6, #48H   ; reload R6 with start of P
        MOV R5, R2     ; reload counter with length

   SUM: XRL @R6 @R3    ; compute final sum
        INC R6         ; move to next bit of P
        INC R3         ; move to next bit of Carry string
        DJNZ R5, SUM

        MOV R6, #48H   ; reset R6 to beginning of result string
        RET            ; result string pointed to by R6
\end{verbatim}


% Now here is the reference section.

\begin{thebibliography}{99}

  % Book
  \bibitem{Weste93} Neil H. E. Weste and Kamran Eshraghian, {\it Principles
  of CMOS VLSI Design}, 2nd ed. Reading, MA: Addison-Wesley, 1993.

  %Example of a Conference Paper
  \bibitem{LiY88} R. A. Lincoln and K. Yao, ``Efficient Systolic Kalman
  Filtering Design by Dependence Graph Mapping,'' in {\it VLSI Signal
  Processing, III}, IEEE Press, R. W. Brodersen and H. S. Moscovitz Eds.,
  1988, pp.~396--410.

  % Example of a Journal Paper
  \bibitem{BiS92} C. H. Bischof and G. M. Shroff, ``On Updating Signal
  Subspaces,'' {\it IEEE Trans. on Signal Processing}, vol.~40, no.~1,
  pp.~96--105, Jan. 1992.

\end{thebibliography}
\end{document}
