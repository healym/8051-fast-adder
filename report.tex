\documentclass[journal]{IEEEtran}
\usepackage{graphics}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}

\begin{document}


\title{Implementation of a Carry Lookahead Fast Adder}
\author{
	Healy, Matthew
	\texttt{mhealy@mst.edu}\\
	\and
	Johnston, Jaxson
	\texttt{jnjt37@mst.edu}\\
	\and
	Grbe\`sa, Lukas
	\texttt{lgqq3@mst.edu}\
}

\maketitle


\begin{abstract}
% write after results calculated

\end{abstract}

\section{Introduction}\label{sec:intro}
The carry lookahead adder was originally patented by Intel\cite{patent} in 1957.
As time passed and technology improved, this method of addition was shown
to be even more useful than originally thought, as it allows for the quick
computation of numbers that would take a non-insignificant amount of time
using the traditional ripple-carry method.

Our goal in this project is to implement a simulation of a carry lookahead
adder on the 8051 microcontroller as a proof of concept. Since execution is
serial, this simulation will not be faster than the built-in adding operations,
as we are unable to calculate multiple things at once, as we could were we
building a hardware model of a carry lookahead adder.

\section{Results and Discussion}\label{sec:discuss}
% edit here

By first generating our Propogate($P$) and Generate($G$) strings from the input,
and then stepping through our carry string and deriving each bit from the
$P$ and $G$ strings and the previous carry bit, we emulate the stages of
operation of a carry lookahead adder.

The $P$ string is created by XORing each pair of respective input bits, and the
$G$ by ANDing together each pair of input bits. This would be done in hardware
with blocks of two logic gates all operating in parallel, and would take
approximately $2\Delta t$ to complete.

The next stage, wherein the $P$ and carry bit are XORed together to create the
sum, is emulated by a loop that XORs bytes of the carry string with bytes of
the $P$ string. While this adds another n time in the software solution, it
would implement only another $2\Delta t$ in a hardware solution, since it would
bo only two more logic gates for each bit, all operating in parallel.

Algorithm \ref{alg:pseudo}
shows the basic implementation of this simulation:
\begin{algorithm}[H]
\caption{Pseudocode for CLA Adder}
\label{alg:pseudo}
\begin{algorithmic}
\State R3 $\rightarrow$ carry string
\State R6 $\rightarrow$ Input A
\State R7 $\rightarrow$ Input B

\ForAll{bytes $P_i\in P, G_i\in G, RX_i\in RX$}
	\State $P \gets R6 \oplus R7$
	\State $G \gets R6 \land R7$
\EndFor
\ForAll{bits $C_i\in C, P_i\in P, G_i\in G$}
	\State $C \gets G \lor (P \land C)$
\EndFor

\ForAll{bytes $SUM_i\in SUM, C_i\in C, P_i\in P$}
	\State $SUM_i \gets C_i \oplus P_i$
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{figure}
	\includegraphics{}
	\caption{Input Size vs Computation Time}
	\label{fig:time}
\end{figure}

As can be seen in Fig. \ref{fig:time}, this software simulation falls far
short of the speed of its hardware implementation. However, it does match very
closely the speed of a ripple-carry add on the 8051 microcontroller, changing
only the constant in the time-complexity.

\section{Summary and Conclusion}

% this needs to be a more concise and digestable version of the results
% and discussion section

\section{Source Code}\label{sec:code}

\lstinputlisting[language=Assembler, firstline=13, basicstyle=\tiny]
{fast_addr.asm}

\begin{thebibliography}{99}

  % Book
  \bibitem{Weste93} Neil H. E. Weste and Kamran Eshraghian, {\it Principles
  of CMOS VLSI Design}, 2nd ed. Reading, MA: Addison-Wesley, 1993.

  %Example of a Conference Paper
  \bibitem{LiY88} R. A. Lincoln and K. Yao, ``Efficient Systolic Kalman
  Filtering Design by Dependence Graph Mapping,'' in {\it VLSI Signal
  Processing, III}, IEEE Press, R. W. Brodersen and H. S. Moscovitz Eds.,
  1988, pp.~396--410.

  % Example of a Journal Paper
  \bibitem{BiS92} C. H. Bischof and G. M. Shroff, ``On Updating Signal
  Subspaces,'' {\it IEEE Trans. on Signal Processing}, vol.~40, no.~1,
  pp.~96--105, Jan. 1992.

\end{thebibliography}
\end{document}
