\documentclass[journal]{IEEEtran}
\usepackage{graphics}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}

\begin{document}


\title{Implementation of a Carry Lookahead Fast Adder}
\author{
	Healy, Matthew
	\texttt{mhealy@mst.edu}\\
	\and
	Johnston, Jaxson
	\texttt{jnjt37@mst.edu}\\
	\and
	Grbe\`sa, Lukas
	\texttt{lgqq3@mst.edu}\
}

\maketitle


\begin{abstract}
% write after results calculated

\end{abstract}

\section{Introduction}\label{sec:intro}
The carry lookahead adder was originally patented by IBM\cite{patent} in 1972.
As time passed and technology improved, this method of addition was shown
to be even more useful than originally thought, as it allows for the quick
computation of numbers that would take a non-insignificant amount of time
using the traditional ripple-carry method.

Our goal in this project is to implement a simulation of a carry lookahead
adder on the 8051 microcontroller as a proof of concept. Since execution is
serial, this simulation will not be faster than the built-in adding operations,
as we are unable to calculate multiple things at once, as we could were we
building a hardware model of a carry lookahead adder.

\section{Approach}\label{sec:approach}
Using the notes given in class it can be seen that in order to determine the
carry value of a certain bit operation can be done by looking at the previous
pair of bits and finding their generate and propagate values and comparing the
propagate value to the carry of the previous bit operation. After a string of
carries is created then all that has to be done is two XOR operations because
XORing the first input with the second input and XORing the result of that
operation with the carry string gives the logical equivalent of adding the two
numbers directly.

\section{Results and Discussion}\label{sec:discuss}
% edit here

By first generating our Propogate($P$) and Generate($G$) strings from the input,
and then stepping through our carry string and deriving each bit from the
$P$ and $G$ strings and the previous carry bit, we emulate the stages of
operation of a carry lookahead adder.

The $P$ string is created by XORing each pair of respective input bits, and the
$G$ by ANDing together each pair of input bits. This would be done in hardware
with blocks of two logic gates all operating in parallel, and would take
approximately $2\Delta t$ to complete.

The next stage, wherein the $P$ and carry bit are XORed together to create the
sum, is emulated by a loop that XORs bytes of the carry string with bytes of
the $P$ string. While this adds another n time in the software solution, it
would implement only another $2\Delta t$ in a hardware solution, since it would
bo only two more logic gates for each bit, all operating in parallel.

Algorithm \ref{alg:pseudo}
shows the basic implementation of this simulation:
\begin{algorithm}[H]
\caption{Pseudocode for CLA Adder}
\label{alg:pseudo}
\begin{algorithmic}
\State R3 $\rightarrow$ carry string
\State R6 $\rightarrow$ Input A
\State R7 $\rightarrow$ Input B

\ForAll{bytes $P_i\in P, G_i\in G, RX_i\in RX$}
	\State $P \gets R6 \oplus R7$
	\State $G \gets R6 \land R7$
\EndFor
\ForAll{bits $C_i\in C, P_i\in P, G_i\in G$}
	\State $C \gets G \lor (P \land C)$
\EndFor

\ForAll{bytes $SUM_i\in SUM, C_i\in C, P_i\in P$}
	\State $SUM_i \gets C_i \oplus P_i$
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{table}
	\caption{Input Size vs Computation Time}
	\label{tab:time}
	\begin{tabular}{|r|r|l|l|}
	\hline
	\textbf{Operand 1} & \textbf{Operand 2} & \textbf{Sum} & \textbf{Time(clock pulses)}\\
	\hline
	$0x8A$ & $0x25$ & $0xAF$ & $0xA0$\\
	\hline
	$0x1FFF$ & $0xA222$ & $0xC111$ & $0x12E$\\
	\hline
	$0x3EFF$ & $0x8AAA$ & $0xC9A9$ & $0x12E$\\
	\hline
	$0x254621$ & $0xAAAAAA$ & $0xCFF0CB$ & $0x01D4$\\
	\hline
	$0x8532AA$ & $0x243699$ & $0xA96943$ & $0x01D5$\\
	\hline
	$0x23456789$ & $0x98765432$ & $0xBBBBBBBB$ & $0x026A$\\
	\hline
	$0xABABABAB$ & $0x11111111$ & $0xBCBCBCBC$ & $0x04C2$\\
	\hline
	$0xC1C1C1C1C1$ & $0x1C1C1C1C1C$ & $0xDDDDDDDDDD$ & $0x0300$\\
	\hline
	$0x123456789ABC$ & $0x123456789ABC$ & $0x2468ACF13578$ & $0x0396$\\
	\hline
	$0x1234567C1C1C1C$ & $0x11AAAAAA8532AA$ & $0x23DF0126A14EC6$ & $0x042E$\\
	\hline
	\end{tabular}
\end{table}

As can be seen in Fig. \ref{tab:time}, this software simulation falls far
short of the speed of its hardware implementation. However, it does match very
closely the speed of a ripple-carry add on the 8051 microcontroller, changing
only the constant in the time-complexity.

\section{Summary and Conclusion}

Upon testing we found that the way the carry lookahead adder has to be
implemented to work in the 8051 it doesn't end up being any faster than simply
adding the two values together. With that said we were still successful in
creating and implementing the carry lookahead adder and if given access to
different hardwaren we would be able to lower the execution time for the
addition.

Using the 8051, is seems that the implementation of a carry lookahead adder is
the best way to increase the processing speed. The only other way that one could
improve the processing time would be to use a multi-core processor and perform
the evaluation of the generators and propagators in one core while another core
evaluates the carries so that the sums can be calculated after only 2t. But with
the hardware at our disposal this is the best that we can do.
% this needs to be a more concise and digestable version of the results
% and discussion section

\section{Source Code}\label{sec:code}

\lstinputlisting[language=Assembler, firstline=13, basicstyle=\tiny]
{fast_addr.asm}

\begin{thebibliography}{99}

	@misc{franz1972parallel,
	  title={Parallel binary carry look-ahead adder system},
	  author={Franz, S. and Dieter, S.},
	  url={https://www.google.com/patents/US3700875},
	  year={1972},
	  month=oct # "~24",
	  publisher={Google Patents},
	  note={US Patent 3,700,875}
	}


\end{thebibliography}
\end{document}
